## 2023-06-03

# Find Components with at Least Three Vertices

Today, I completed the implementation of the component counting functionality in the project. The goal was to determine the number of connected components in the graph that have at least three vertices. To accomplish this, I used depth-first search (DFS) to traverse the graph.

I wrote the following code to count the components:

```java
/**
 * Counts the number of connected components in the graph that have at least three vertices.
 * Uses depth-first search (DFS) to traverse the graph.
 *
 * @return The count of components with at least three vertices.
 *
 * Time Complexity: O(V + E) where V is the number of nodes and E is the number of edges in the graph.
 */
public int countComponents() {
    Set<Integer> visited = new HashSet<>(); // We use a HashSet instead of an array for better time complexity (contains operation)
    int componentCount = 0;

    for (int node : graph.keySet()) {
        if (!visited.contains(node)) {
            // if vertex count >= 3, add 1 to componentCount, else add 0 (ternary)
            componentCount += (dfsCountNodes(node, visited) >= 3) ? 1 : 0;
        }
    }

    return componentCount;
}

// DFS helper for counting nodes, returns vertex count
private int dfsCountNodes(int node, Set<Integer> visited) {
    visited.add(node);
    int verticesCount = 1;

    for (int neighbor : graph.get(node)) {
        verticesCount += (!visited.contains(neighbor)) ? dfsCountNodes(neighbor, visited) : 0;
    }

    return verticesCount;
}
```

To ensure the correctness of the implementation, I tested it on a small test dataset. I created the graph via the smaller test data files I created yesterday (see entry for 2023-06-02) with a few vertices and edges, and verified that the count of components with at least three vertices matched my expected results.

The cleaned version of the graph from the entire dataset that we are working with contains 226,796 components with at least three vertices.

```
❯ java -Xss1G -Xms24G -jar GraphProcessor.jar ../overlaps.m4/cleaned.m4
Number of components with at least three vertices: 226796
```

The time complexity of the countComponents method is $O(|V| + |E|)$, where $|V|$ is the number of nodes and $|E|$ is the number of edges in the graph.

# Histogram of the Component Density Distribution

I also completed the implementation of the histogram code for the component density distribution today. The goal was to analyze the density of each component in the graph that has at least three vertices. The density of a component is defined as twice the number of edges divided by the number of nodes times the number of nodes minus one, or the fraction of edges divided by the number of possible edges for each component.

To accomplish this task, I implemented the following algorithms and functionalities:

1. `calculateComponentDensityToFile(filename)`: This method writes the density of each component with at least three vertices to a file. The filename is provided as the base filename, followed by "\_component_densities.txt". I used a `PrintWriter` to write the densities to the file.

2. `calculateDensity(component)`: This method calculates the density of a given component. It iterates through each node in the component and checks its neighbors to count the number of edges. The density is then computed using the formula $\frac{2 _ |E|}{|V|  (|V| - 1)}$, [this comes from [Dense Graph Wikipedia Page](https://en.wikipedia.org/wiki/Dense_graph)] where $|E|$ is the number of edges and $|V|$ is the number of nodes in the component. Note that on the Wikipedia page it says that this is the formula for undirected simple graphs, but since each component (subgraph) is it self a graph and our graph is simple and undirected, so we can use this for the component density as well.

3. `dfsDensity(node, visited, component)`: This is a depth-first search (DFS) helper method that populates the `component` set with the nodes of the component to which the `node` belongs. It recursively explores the neighboring nodes and marks them as visited.

The Python script `plot_component_density_histogram.py` is used to generate the histogram from the file generated by the Java program. The script reads the component densities from the file and uses the matplotlib library to plot the histogram in both linear and logarithmic scales. The histogram is saved as PNG images.

## Algorithm Complexity Analysis

- Time Complexity: The time complexity of the `calculateComponentDensityToFile` method is $O(|V| + |E|)$, where $|V|$ is the number of nodes and $|E|$ is the number of edges in the graph. This is because the method performs a depth-first search on the graph, visiting each node and its neighbors once. The `calculateDensity` method has a nested loop that iterates through each node and its neighbors, resulting in a time complexity of $O(N^2)$, where $N$ is the number of nodes in the component.

- Space Complexity: The space complexity of the algorithms mainly depends on the size of the graph and the components. The `calculateComponentDensityToFile` method uses a HashSet to keep track of visited nodes, which requires $O(|V|)$ space. The `calculateDensity` method uses additional space to store the component nodes and neighbors, resulting in a space complexity of $O(N)$, where $N$ is the number of nodes in the component.

### Usage

To plot a histogram we need to first generate the .txt file with the densities by running the Java program:

```bash
❯ java -Xss1G -Xms24G -jar GraphProcessor.jar ../overlaps.m4/cleaned.m4
```

(ran from src directory, change flags if needed)

This takes about 70 seconds for me. Now we have

```bash
project_genome_assembly_graph on feature/component_density_distribution [!]
❯ tree .
.
├── doc
│   ├── notebook
│   │   ├── 2023-05-15.md
│   │   ├── 2023-05-23.md
│   │   ├── 2023-05-27.md
│   │   ├── 2023-06-02.md
│   │   └── 2023-06-03.md
│   └── report.md
├── out
│   └── production
│       └── project_genome_assembly_graph
│           ├── DegreeDistribution.class
│           ├── degree_distribution.py
│           ├── GraphPreprocessor.class
│           ├── graph_processing.py
│           └── GraphProcessor.class
├── overlaps.m4
│   ├── cleaned_component_densities.txt
│   ├── cleaned_degrees.txt
│   ├── cleaned.m4
│   ├── Spruce_fingerprint_2017-03-10_16.48.olp.m4
│   ├── test_data0.m4
│   └── test_data1.m4
├── project_genome_assembly_graph.iml
├── README.md
└── src
    ├── GraphProcessor.class
    ├── GraphProcessor.jar
    ├── GraphProcessor.java
    ├── MANIFEST.MF
    ├── plot_component_density_histogram.py
    └── plot_degree_histogram.py

8 directories, 25 files
```

In the overlaps directory we created a file called `cleaned_component_densities.txt` which we will use to create a the histograms:

```bash
❯ python src/plot_component_density_histogram.py overlaps.m4/cleaned_component_densities.txt
```

This creates two PNG images:

```bash
❯ ls overlaps.m4/cleaned_*.png
Permissions Size User Date Modified Name
.rw-r--r--  124k emil  3 jun 20:32  overlaps.m4/cleaned_component_densities_linear.png
.rw-r--r--   97k emil  3 jun 20:32  overlaps.m4/cleaned_component_densities_log.png
```

These and other images will be commited to a directory called images.

I had an error where the density of a few components were greater than one, this is impossible, but I'm quite sure that there is nothing wrong with the code. So I decided to just ignore these components. I assume this is because the graph is 'messy.'
