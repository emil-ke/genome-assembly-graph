Started with the graph analysis today, and I have made progress in representing the graph. I also created some test data:

```
fp.3.Luci_01A01.ctg.ctg7180000038386    fp.3.Luci_02C06.ctg.ctg7180000060335    5       1       0       6835    7893    28201   0       0       1058    1058
fp.3.Luci_01A01.ctg.ctg7180000038386    fp.3.Luci_02C06.ctg.ctg7180000085546    30      0.99445 0       3977    6845    28201   0       0       2883    2883
fp.3.Luci_01A01.ctg.ctg7180000038386    fp.3.Luci_03C06.ctg.ctg7180000085693    64      0.99982 0       7891    13435   28201   1       0       5544    5544

```

The graph implicitly defined by this data has four vertices (corresponding to four different identifiers), and the degrees of the vertices are (3, 1, 1, 1). This is because `fp.3.Luci_01A01.ctg.ctg7180000038386` is connected to each of the other vertices. Note that this also accounts for the overlap requirement, i.e. the overlap is considered "sufficiently large".

I implemented a simple degree distribution algorithm, and it appears to work correctly for the test data. However, there is still more work to be done to complete the analysis.

Here is the output of the degree distribution algorithm for the test data:

```
‚ùØ java DegreeDistribution test_data.m4
Vertex fp.3.Luci_02C06.ctg.ctg7180000085546: Degree 1
Vertex fp.3.Luci_01A01.ctg.ctg7180000038386: Degree 3
Vertex fp.3.Luci_02C06.ctg.ctg7180000060335: Degree 1
Vertex fp.3.Luci_03C06.ctg.ctg7180000085693: Degree 1
```
