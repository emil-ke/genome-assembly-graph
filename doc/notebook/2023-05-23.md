Started with the graph analysis today, I can now represent the graph to some extent. I also create a some test data:

```
fp.3.Luci_01A01.ctg.ctg7180000038386    fp.3.Luci_02C06.ctg.ctg7180000060335    5       1       0       6835    7893    28201   0       0       1058    1058
fp.3.Luci_01A01.ctg.ctg7180000038386    fp.3.Luci_02C06.ctg.ctg7180000085546    30      0.99445 0       3977    6845    28201   0       0       2883    2883
fp.3.Luci_01A01.ctg.ctg7180000038386    fp.3.Luci_03C06.ctg.ctg7180000085693    64      0.99982 0       7891    13435   28201   1       0       5544    5544

```

The graph which this implicitly defines has four vertices (there are 4 different identifiers) and the degrees are (3, 1, 1, 1) because fp.3.Luci_01A01.ctg.ctg7180000038386 is connected to each other node (this also takes into account the overlap requirement, i.e. the overlap is 'sufficiently large'). I also wrote a simple degree distribution algorithm and it seems to work for the test data at least. This still needs a lot of work however.

```
‚ùØ java DegreeDistribution test_data.m4
Vertex fp.3.Luci_02C06.ctg.ctg7180000085546: Degree 1
Vertex fp.3.Luci_01A01.ctg.ctg7180000038386: Degree 3
Vertex fp.3.Luci_02C06.ctg.ctg7180000060335: Degree 1
Vertex fp.3.Luci_03C06.ctg.ctg7180000085693: Degree 1
```
